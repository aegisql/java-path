options
{
  JDK_VERSION = "1.8";
  IGNORE_CASE=false;
  VISITOR=true;
  MULTI=true;
//  DEBUG_PARSER=true;
//  DEBUG_LOOKAHEAD=true ;
//  FORCE_LA_CHECK=true;
//  DEBUG_TOKEN_MANAGER=true;
  UNICODE_INPUT=true;
}

PARSER_BEGIN(CCJavaPathParser)
package com.aegisql.java_path.parser;

import com.aegisql.java_path.TypedValue;
import com.aegisql.java_path.TypedPathElement;
import com.aegisql.java_path.JavaPathRuntimeException;

public class CCJavaPathParser {}

PARSER_END(CCJavaPathParser)

TOKEN :
{
  <K_LPARENTHESIS : "(">
| <K_RPARENTHESIS : ")">
| <K_DOT: ".">
| <K_OR: "||">
| <K_FACTORY_SEPARATOR: "::">
| <K_COMMA: ",">
| <K_SPACE: ([" ","\t","\n","\r"])+>
| < #LETTER: ["a"-"z","A"-"Z"] >
| < #DIGIT: ["0"-"9"] >
| < #SPECIAL: ["_","<","-",">","$"] >
| <K_BACK_REF_ELEMENT : "#"(<DIGIT> )*>
| <K_REF_ELEMENT : "$"(<DIGIT> )*>
| < K_TYPE_ELEMENT: ((<LETTER>|<DIGIT>|<SPECIAL> )+ ( <K_DOT> (<LETTER> | <DIGIT>|<SPECIAL> )+ )*( <K_FACTORY_SEPARATOR> (<LETTER> | <DIGIT>|<SPECIAL> )+ )? <K_SPACE>) >
| < K_PATH_ELEMENT: ( ~["'","\""," ","\t",".",",","(",")","\\","|"] )+ >
| <K_QUOTED_STRING: "\"" ( (~["\"","\\"]) | ("\\" ( ["n","t","b","r","f","\\","\""] ) ) )* "\"">
| <K_SINGLE_QUOTED_STRING: "\'" ( (~["\'","\\"]) | ("\\" ( ["n","t","b","r","f","\\","\'"] ) ) )* "\'">
}

void comma() :
{}
{
    <K_COMMA>[<K_SPACE> ]
}

void lParenthesis() :
{}
{
    <K_LPARENTHESIS>
}

void rParenthesis() :
{}
{
    <K_RPARENTHESIS>
}

void option() :
{
    Token t = null;
}
{
    ( <K_DOT> | t = <K_OR> )
    {
        jjtThis.jjtSetValue(t != null);
    }
}

/** Root production. */
SimpleNode parse() :
{
    String type = null;
    Token ref = null;
    TypedPathElement typedPathElement = null;
}
{
    (
        LOOKAHEAD(3) <K_LPARENTHESIS> type = fullType() ref = <K_BACK_REF_ELEMENT> <K_RPARENTHESIS><K_DOT> fullPath()
            {
            String root = ref.image;
            if(! ("#".equals(root) || "#0".equals(root)) ) {
                throw new JavaPathRuntimeException("wrong root back reference "+root);
            }
            typedPathElement = new TypedPathElement();
            typedPathElement.setName(root);
            typedPathElement.setType(type);
            }
        |
        ref = <K_BACK_REF_ELEMENT> <K_DOT> fullPath()
            {
            String root = ref.image;
            if(! ("#".equals(root) || "#0".equals(root)) ) {
                throw new JavaPathRuntimeException("wrong root back reference "+root);
            }
            typedPathElement = new TypedPathElement();
            typedPathElement.setName(root);
            }
        |
        fullPath()
    ) [<K_DOT> fullPath() ]
    <EOF>
    {
        jjtThis.jjtSetValue(typedPathElement);
        return jjtThis;
    }

}


void fullPath() :
{
    String type = null;
}
{
    (
        <K_LPARENTHESIS> [type = fullType()] parametrizedPathElement() <K_RPARENTHESIS>
        |
        parametrizedPathElement()
    ) [option() fullPath() ]
    <EOF>
    {
        jjtThis.jjtSetValue(type);
    }
}

String path() #void:
{
    String type = null;
}
{
    (
    lParenthesis() [type = fullType()] parametrizedPathElement() rParenthesis() [<K_DOT> path() ]
    |
    parametrizedPathElement() [<K_DOT> path() ]
    )
    {
        return type;
    }
}

void parametrizedPathElement() #void:
{}
{
    pathElement() [lParenthesis() [parameters()] rParenthesis() ]
}

void pathElement() :
{
    Token t = null;
}
{
    t = <K_PATH_ELEMENT>
    {
        jjtThis.jjtSetValue(t.image);
    }
}

String fullType() #void:
{
    Token t = null;
}
{
    t = <K_TYPE_ELEMENT>
    {
        return t.image.trim();
    }
}

TypedValue backRef() #void:
{
    Token t = null;
    String type = null;
    String factory = null;
}
{
    t = <K_BACK_REF_ELEMENT> [<K_DOT> type = path() ]
    {
    TypedValue tv = new TypedValue();
    String numStr = t.image;
    if("#".equals(numStr)) {
        tv.setBackRefIdx(0);
    } else {
        tv.setBackRefIdx(Integer.valueOf(numStr.substring(1)));
    }
    if(type != null && type.contains("::")) {
        String[] pair = type.split("::",2);
        type = pair[0];
        factory = pair[1];
    }
    tv.setType(type);
    tv.setFactory(factory);
    tv.setValue(numStr);
    return tv;
}
}

TypedValue forwardRef() #void:
{
    String type = null;
    String value = null;
    String factory = null;
}
{
    (
        LOOKAHEAD(fullType() parameter() )type = fullType() value = parameter()
        |
        value = parameter()
    )
    {
        TypedValue tv = new TypedValue();
        if(type != null && type.contains("::")) {
            String[] pair = type.split("::",2);
            type = pair[0];
            factory = pair[1];
        }
        tv.setType(type);
        tv.setFactory(factory);
        tv.setValue(value);
        tv.setBackRefIdx(-1);
        if(value.startsWith("$")) {
            if("$".equals(value)) {
                tv.setValueIdx(0);
            } else {
                tv.setValueIdx(Integer.valueOf(value.substring(1)));
            }
        }
        return tv;
    }
}

void parameters() :
{
    TypedValue tv = null;
}
{
    (
        tv = backRef()
        |
        tv = forwardRef()
    ) [comma() parameters() ]
    {
        jjtThis.jjtSetValue(tv);
    }
}

String parameter() #void:
{
    Token t = null;
}
{
    (
        (t = <K_REF_ELEMENT> [<K_DOT> path() ])
        |
        t = <K_PATH_ELEMENT>
        |
        t = <K_QUOTED_STRING>
        |
        t = <K_SINGLE_QUOTED_STRING>
    )
    {
        return t.image;
    }
}
